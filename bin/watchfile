#!/usr/bin/env bash

# usage
USAGE="Usage:
    `basename $0` [file] [command as string]"
[[ -z "$2" ]]      && echo -e "${USAGE}" && exit 1
[[ -n "$3" ]]      && echo -e "${USAGE}" && exit 1
[[ "$1" == "-h" ]] && echo -e "${USAGE}" && exit 0
[[ "$2" == "-h" ]] && echo -e "${USAGE}" && exit 0

# store file info
FILE_PATH="$(realpath $1)"
COMMAND="$2"

# function to compile project and execute the binary
function build_and_execute() {
    # kill internal processes on exit
    trap 'jobs -p | xargs kill' EXIT

    # attempt to build project
    clear # clear screen

    # execute the built binary
    echo -e       "--------- Executing ---------\n"
    eval ${COMMAND} &&
        echo -e "\n-----------------------------\n" &&
        echo "Watching \"${FILE_PATH}\"..."
}

function watch_file() {
    # exit script on ctrl-c
    trap 'echo ": Interrupted" && exit 1' INT

    # build and execute the file once first
    build_and_execute &
        task_pid=$!

    # watch file for changes, terminate and rebuild
    while true; do
        # wait for changes...
        [[ -n "$(fswatch ${FILE_PATH} -1)" ]] &&
            echo "Re-executing..."
        kill ${task_pid} &> /dev/null
        wait ${task_pid} &> /dev/null

        # wait $delay seconds for subsequent events to finish
        delay=0.4
        files_changed=true
        while [[ ${files_changed} = true ]]; do
            if [[ -n "$(timeout ${delay} fswatch ${FILE_PATH} -1 -l 0.1)" ]]; then
                echo "keep changin'"
                files_changed=true
            else
                files_changed=false
            fi
        done

        # build and execute the file
        build_and_execute &
            task_pid=$!
    done
}

watch_file
