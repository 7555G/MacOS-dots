#!/usr/bin/env bash

# usage
USAGE="Usage:
    `basename $0` [file] [command as string]"
[[ -z "$2" ]]      && echo -e "${USAGE}" && exit 1
[[ -n "$3" ]]      && echo -e "${USAGE}" && exit 1
[[ "$1" == "-h" ]] && echo -e "${USAGE}" && exit 0
[[ "$2" == "-h" ]] && echo -e "${USAGE}" && exit 0

# store file info
FILE_PATH="$(realpath $1)"
COMMAND="$2"

# function to print timestamp
timestamp() {
    echo "[$(date "+%T")]"
}

# function to execute command
function execute_cmd() {
    # kill internal processes on exit
    trap 'jobs -p | xargs kill &> /dev/null' EXIT INT

    # execute the command
    #clear
    echo -e "---------- $(timestamp) Executing ----------\n"
    eval "${COMMAND}"

    if [[ $? == 0 ]]; then
        echo -e "\n------------------------------------------\n"
        echo "$(timestamp) Watching \"${FILE_PATH}\"..."
    fi
}

function main() {
    local exec_pid
    local watch_pid
    local changed=false
    local t=0.4
    local l=0.1

    # exit script on ctrl-c
    trap 'echo ": $(timestamp) Interrupted" && exit 1' INT

    # execute command once first
    execute_cmd &
        exec_pid=$!

    # watch file for changes, terminate and re-execute
    while true; do
        # wait for further changes...
        changed="$(fswatch "${FILE_PATH}" --event "Updated" -1 --latency ${l})"
        echo "$(timestamp) File changed"

        # kill previous execution
        kill ${exec_pid} &> /dev/null
        wait ${exec_pid} &> /dev/null

        # keep watching for ${timeout} seconds for further changes
        while [[ -n ${changed} ]]; do
            echo "$(timestamp) Waiting for further changes..."
            changed="$( \
                timeout --foreground ${t} \
                fswatch "${FILE_PATH}" --event "Updated" -1 --latency ${l})"
        done

        # execute command
        execute_cmd &
            exec_pid=$!
    done
}

main
