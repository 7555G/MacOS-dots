#!/usr/bin/env bash

# styling
BR_TEXT='\033[1;97m'
RED_TEXT='\033[1;31m'
TEXT='\033[0m'

# usage
USAGE="Usage:
    $(basename "$0") [file] [command as string]"
[[ -z "$2" ]]      && echo -e "${USAGE}" && exit 1
[[ -n "$3" ]]      && echo -e "${USAGE}" && exit 1
[[ "$1" == "-h" ]] && echo -e "${USAGE}" && exit 0
[[ "$2" == "-h" ]] && echo -e "${USAGE}" && exit 0

# store file info
FILE_PATH="$(realpath "$1")"
COMMAND="$2"

# function to print timestamp
timestamp() {
    echo "[$(date "+%T.%3N")]"
}

# function to execute command
function execute_cmd() {
    # kill internal processes on exit
    trap 'jobs -p | xargs kill &> /dev/null' EXIT INT

    # execute the command
    #clear
    echo -e       "${BR_TEXT}========== $(timestamp) Executing ==========${TEXT}\n"
    if eval "${COMMAND}"; then
        echo -e "\n${BR_TEXT}========== $(timestamp) Finished ===========${TEXT}"
    else
        echo -e "\n${BR_TEXT}========== $(timestamp) Failed =============${TEXT}"
    fi
    echo -e "${BR_TEXT}$(timestamp) Watching \"${FILE_PATH}\"...${TEXT}"
}

function main() {
    local exec_pid
    local changed=false
    local t=0.4
    local l=0.1

    # exit script on ctrl-c
    trap 'echo -e "${BR_TEXT}$(timestamp) Interrupted${TEXT}" && exit 1' INT

    # execute command once first
    execute_cmd &
        exec_pid=$!

    # watch file for changes, terminate and re-execute
    while true; do
        # watch for changes...
        changed="$(fswatch "${FILE_PATH}" -1 --latency ${l})"
        echo "$(timestamp) File changed"

        # kill current execution
        kill ${exec_pid} &> /dev/null
        wait ${exec_pid} &> /dev/null

        # keep watching for ${timeout} seconds for further changes
        while [[ -n ${changed} ]]; do
            echo "$(timestamp) Waiting for further changes..."
            changed="$( \
                timeout --foreground ${t} \
                fswatch "${FILE_PATH}" --event "Updated" -1 --latency ${l})"
        done

        # execute command
        execute_cmd &
            exec_pid=$!
    done
}

main
