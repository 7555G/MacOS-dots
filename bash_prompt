#!/usr/bin/env bash
# shellcheck disable=SC2034
# shellcheck disable=SC1083

set_prompt() {
    local session_type="$1"

    # Reset
    local Reset='\[\e[0m\]'

    # Bold
    local Bold='\[\e[0;1m\]'

    # Underline
    local Underline='\[\e[0;4m\]'

    # Bold underline
    local BoldUnderline='\[\e[0;1;4m\]'

    # Regular foreground
    local Black='\[\e[30m\]'
    local Red='\[\e[31m\]'
    local Green='\[\e[32m\]'
    local Yellow='\[\e[33m\]'
    local Blue='\[\e[34m\]'
    local Magenta='\[\e[35m\]'
    local Cyan='\[\e[36m\]'
    local White='\[\e[37m\]'

    # High Intensity foreground
    local IBlack='\[\e[90m\]'
    local IRed='\[\e[91m\]'
    local IGreen='\[\e[92m\]'
    local IYellow='\[\e[93m\]'
    local IBlue='\[\e[94m\]'
    local IMagenta='\[\e[95m\]'
    local ICyan='\[\e[96m\]'
    local IWhite='\[\e[97m\]'

    # Regular background
    local OnBlack='\[\e[40m\]'
    local OnRed='\[\e[41m\]'
    local OnGreen='\[\e[42m\]'
    local OnYellow='\[\e[43m\]'
    local OnBlue='\[\e[44m\]'
    local OnMagenta='\[\e[45m\]'
    local OnCyan='\[\e[46m\]'
    local OnWhite='\[\e[47m\]'

    # High Intensity background
    local OnIBlack='\[\e[100m\]'
    local OnIRed='\[\e[101m\]'
    local OnIGreen='\[\e[102m\]'
    local OnIYellow='\[\e[103m\]'
    local OnIBlue='\[\e[104m\]'
    local OnIMagenta='\[\e[105m\]'
    local OnICyan='\[\e[106m\]'
    local OnIWhite='\[\e[107m\]'

    # get the prompt user
    local user="${IBlue}\${USER}${Reset}"
    if [[ "${session_type}" == "remote_ssh" ]]; then
        user="${user} ${IBlack}(ssh)${Reset}"
    fi

    # get the hostname
    local hostname=" at ${Cyan}\${HOSTNAME%.local}${Reset}"

    # get conda level and environment
    if [[ -n "${CONDA_DEFAULT_ENV}" ]]; then
        # get conda nest level
        # TODO
        local conda_lvl="$(format_nest_level "${CONDA_SHLVL}")"
        if [[ -n "${CONDA_STACKED_2}" ]]; then
            local is_stacked="${IGreen}"
        fi
        local conda_env=" using ${Green}\${CONDA_DEFAULT_ENV}${Reset}${is_stacked}${conda_lvl}${Reset}"
    fi

    # get virtualenv level and environment
    if [[ -n "${VIRTUAL_ENV}" ]]; then
        local virtualenv_env="(${Green}$(basename "${VIRTUAL_ENV}")${Reset})"
    fi

    # get the working directory
    local work_dir=" in ${Bold}${Blue}\w${Reset}"

    # get prompt sign and nest level
    local prompt_sign="${Bold}${IBlack}"'\n\$'"${Reset}"
    local shell_lvl="${IBlack}$(format_nest_level "${SHLVL}")${Reset}"

    # check if current dir belongs to overlayed ROS package
    if command -v "catkin" &> /dev/null \
        && command -v "rospack" &> /dev/null; then
        local ros_srcd

        local current_workspace="$(catkin locate 2> /dev/null)"
        if [[ -z "${current_workspace}" ]]; then
            ros_srcd=""
        elif rospack list | grep --max-count 1 "${current_workspace}" &> /dev/null; then
            ros_srcd="${Green}✔︎${Reset}"
        fi
    fi

    # return the prompt string
    echo "  ${user}${hostname}${conda_env}${virtualenv_env}${work_dir}${ros_srcd}${prompt_sign}${shell_lvl}"
}

# construct an indicator based on the nesting level
format_nest_level() {  # TODO: doesn't work with root
    # check shell nest level
    case $1 in
        0* | 1*)
            ;;
        2)
            echo "❭"
            ;;
        *)
            echo "\$(($1 - 1))❭"
            ;;
    esac
}

# callback to print the last command exit status
print_last_status () {
    local last_status=$?
    local IBlack="\e[90m"
    local Reset="\e[0m"
    echo -e "${IBlack}Exit ${last_status}${Reset}"
}

# notify the terminal
#if [[ "${session_type}" == "remote_ssh" ]]; then
#    export PROMPT_COMMAND+='echo -ne "\e]0;${HOSTNAME%.*}::$(dirs +0)\007"; '
#else
#    export PROMPT_COMMAND+='echo -ne "\e]0;$(dirs +0)\007"; '
#fi

# make git prompt command available
if [[ -f "${HOMEBREW_PREFIX}/etc/bash_completion.d/git-prompt.sh" ]]; then
    source "${HOMEBREW_PREFIX}/etc/bash_completion.d/git-prompt.sh"
elif [[ -f "${HOMEBREW_PREFIX}/etc/bash_completion.d/git-prompt" ]]; then
    source "${HOMEBREW_PREFIX}/etc/bash_completion.d/git-prompt"
fi

# git prompt options
export GIT_PS1_SHOWCOLORHINTS=true
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_DESCRIBE_STYLE="contains"
export GIT_PS1_SHOWUNTRACKEDFILES=true
export GIT_PS1_SHOWUPSTREAM="auto"

export -f set_prompt

export PROMPT_COMMAND="${PROMPT_COMMAND%; }"'; __git_ps1 "$(set_prompt "'"${session_type}"'")" " "'
export PROMPT_COMMAND="${PROMPT_COMMAND%; }; trap print_last_status ERR"
export PS1="$(set_prompt "${session_type}")"  # is set by __git_ps1
export PS2='\[\e[30m\]┃\[\e[0m\] '
